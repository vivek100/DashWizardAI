import React, { useState, useRef, useEffect } from 'react';
import { useAppStore } from '@/store/appStore';
import { useDashboardStore } from '@/store/dashboardStore';
import { useDataStore } from '@/store/dataStore';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Avatar, AvatarFallback } from '@/components/ui/avatar';
import { Badge } from '@/components/ui/badge';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { ScrollArea, ScrollBar } from '@/components/ui/scroll-area';
import { Separator } from '@/components/ui/separator';
import { 
  Send, Brain, User, Sparkles, Code, Upload, Eye, Save, Edit, 
  Play, Download, Plus, AlertCircle, CheckCircle, TrendingUp,
  BarChart3, Table as TableIcon, PieChart, FileText, Database, Zap, Wrench
} from 'lucide-react';
import { format } from 'date-fns';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";

// Import widget components
import { ChartWidget } from '@/components/dashboards/widgets/ChartWidget';
import { TableWidget } from '@/components/dashboards/widgets/TableWidget';
import { MetricWidget } from '@/components/dashboards/widgets/MetricWidget';
import { TextWidget } from '@/components/dashboards/widgets/TextWidget';
import { CSVUploadDialog } from '@/components/data/CSVUploadDialog';
import { DashboardViewer } from '@/components/dashboards/DashboardViewer';
import { useAgentStream, Message } from '@/hooks/useLangGraphStream'; // Import the new hook
import { toast } from 'sonner';

import { 
  EnhancedChatMessage, AIResponse, AIComponent, Widget, Dashboard,
  WidgetComponentData, DashboardComponentData, SQLResultComponentData,
  UploadPromptComponentData, ErrorComponentData
} from '@/types';

interface ChatInterfaceProps {
  onDashboardAction?: (action: 'create' | 'edit', dashboard: Dashboard) => void;
  currentDashboard?: Dashboard | null;
}

// Deduplicate messages (from demo app)
function dedupeMessages(messages: Message[]): Message[] {
  const messageMap = new Map<string, Message>();
  messages.forEach(message => {
    const key = message.id || `${message.type}-${message.name || 'unknown'}-${JSON.stringify(message.content)}`;
    messageMap.set(key, message);
  });
  return Array.from(messageMap.values());
}

// Convert agent messages to EnhancedChatMessage format
function convertToEnhancedMessage(message: Message): EnhancedChatMessage {
  const role = message.type === 'human' ? 'user' : 'assistant';
  let aiResponse: AIResponse | undefined;
  let content = typeof message.content === 'string' ? message.content : JSON.stringify(message.content);

  if (message.type === 'ai' && Array.isArray(message.tool_calls) && message.tool_calls.length > 0) {
    content = "Tool Call Initiated: "+message.tool_calls[0].name+" was called.";
    aiResponse = {
      text: "Tool Call Initiated: "+message.tool_calls[0].name+" was called.",
      components: message.tool_calls.map((call, idx) => ({
        type: 'tool_call',
        id: call.id || `tool-call-${idx}`,
        data: {
          name: call.name,
          args: call.args
        }
      }))
    };
  } else if (message.type === 'tool') {
    content = "Tool Call Completed: "+message.name+" tool returned a response.";
    aiResponse = {
      text: "Tool Call Completed: "+message.name+" tool returned a response.",
      components: [{
        type: 'tool_result',
        id: message.id || `tool-result-${Date.now()}`,
        data: {
          name: message.name,
          result: message.content
        }
      }]
    };
  } else if (message.type === 'ai') {
    aiResponse = { text: content };
  }

  return {
    id: message.id || Date.now().toString(),
    content,
    role,
    timestamp: new Date(message.created_at ?? Date.now()),
    aiResponse,
    suggestions: message.type === 'ai' ? [
      'Create a dashboard from this',
      'Show more details',
      'Analyze further',
      'Export data'
    ] : undefined
  };
}

export function ChatInterface({ onDashboardAction, currentDashboard }: ChatInterfaceProps) {
  const { addAlert } = useAppStore();
  const { 
    dashboards, setCurrentDashboard, 
    createDashboard, updateDashboard, addWidget 
  } = useDashboardStore();
  const { tables, views, executeQuery, addDataSource, isInitialized, initialize } = useDataStore();
  
  const [input, setInput] = useState('');
  const [isTyping, setIsTyping] = useState(false);
  const [uploadDialogOpen, setUploadDialogOpen] = useState(false);
  const [dashboardPreview, setDashboardPreview] = useState<Dashboard | null>(null);
  const [lastError, setLastError] = useState<string | null>(null);
  const [isInitializing, setIsInitializing] = useState(true);
  const scrollRef = useRef<HTMLDivElement>(null);

  const { messages, submit, isLoading, error } = useAgentStream(); // Use new agent hook
  const displayMessages = dedupeMessages(messages).map(convertToEnhancedMessage);
  const [lastUserInput, setLastUserInput] = useState('');
  const [lastUserMessageId, setLastUserMessageId] = useState<string>('');
  const [collapsedToolResults, setCollapsedToolResults] = useState<{ [key: string]: boolean }>({});
  // Initialize welcome message
  useEffect(() => {
    const initializeAndSetWelcome = async () => {
      try {
        setIsInitializing(true);
        await initialize();
        
        // Set welcome message matching demo app
        // This part is now handled by the welcome section in the render function
      } catch (error) {
        console.error('Failed to initialize database:', error);
        // This part is now handled by the welcome section in the render function
      } finally {
        setIsInitializing(false);
      }
    };

    initializeAndSetWelcome();
  }, [initialize]);

  useEffect(() => {
    scrollRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [displayMessages]);

  // Show loading state while database initializes
  if (isInitializing) {
    return (
      <div className="flex h-full">
        <div className="flex-1 flex flex-col">
          <ScrollArea className="flex-1 p-4">
            <div className="space-y-4 max-w-4xl mx-auto">
              <div className="space-y-2">
                <div className="flex items-start space-x-3">
                  <Avatar className="w-8 h-8 bg-gradient-to-br from-emerald-400 via-blue-500 to-purple-600 flex-shrink-0 shadow-sm">
                    <AvatarFallback className="bg-transparent">
                      <Brain className="w-4 h-4 text-white drop-shadow-sm" />
                    </AvatarFallback>
                  </Avatar>
                  <div className="max-w-[80%] min-w-0">
                    <Card className="p-3 bg-white border-gray-200">
                      <div className="flex items-center space-x-2">
                        <div className="flex space-x-1">
                          <div className="w-2 h-2 bg-blue-400 rounded-full animate-bounce"></div>
                          <div className="w-2 h-2 bg-blue-400 rounded-full animate-bounce" style={{ animationDelay: '0.1s' }}></div>
                          <div className="w-2 h-2 bg-blue-400 rounded-full animate-bounce" style={{ animationDelay: '0.2s' }}></div>
                        </div>
                        <span className="text-sm text-gray-600">Initializing database and sample data...</span>
                      </div>
                    </Card>
                  </div>
                </div>
              </div>
            </div>
          </ScrollArea>
          <div className="border-t border-gray-200 p-4">
            <div className="max-w-4xl mx-auto space-y-4">
              <div className="flex space-x-2 items-end">
                <div className="flex-1 relative">
                  <Textarea
                    value=""
                    placeholder="Initializing database, please wait..."
                    className="min-h-[40px] max-h-32 text-sm resize-none border-gray-300 w-full"
                    disabled={true}
                    rows={1}
                  />
                </div>
                <Button
                  disabled={true}
                  size="sm"
                  className="px-4 h-10 flex-shrink-0"
                >
                  <Send className="w-4 h-4" />
                </Button>
              </div>
            </div>
          </div>
        </div>
      </div>
    );
  }

  const handleSend = async () => {
    if (!input.trim()) return;
  
    const userInput = input.trim();
    const userMessageId = Date.now().toString();
    const userMessage: Message = {
      id: userMessageId,
      type: 'human',
      content: userInput,
      created_at: new Date().toISOString(),
    };
  
    setLastUserInput(userInput);
    setLastUserMessageId(userMessageId); // Store user message ID
    setInput('');
    setIsTyping(true);
  
    try {
      await submit({
        messages: userMessage,
      });
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Unknown error occurred';
      setLastError(errorMessage);
      toast.error(`Action failed: ${errorMessage}`);
    } finally {
      setIsTyping(false);
      setLastUserInput('');
      setLastUserMessageId(''); // Clear after submission
    }
  };

  const findAvailablePosition = (widgets: Widget[], newWidget: Widget) => {
    const gridSize = 20;
    let x = 0;
    let y = 0;
    
    const isPositionOccupied = (testX: number, testY: number) => {
      return widgets.some(widget => {
        const widgetRight = widget.position.x + widget.size.width;
        const widgetBottom = widget.position.y + widget.size.height;
        const newRight = testX + newWidget.size.width;
        const newBottom = testY + newWidget.size.height;
        
        return !(testX >= widgetRight || newRight <= widget.position.x || 
                testY >= widgetBottom || newBottom <= widget.position.y);
      });
    };

    while (isPositionOccupied(x, y)) {
      x += gridSize;
      if (x > 800) {
        x = 0;
        y += gridSize;
      }
    }

    return { x, y };
  };

  const handleComponentAction = async (action: string, componentId: string, data?: any) => {
    try {
      switch (action) {
        case 'save_dashboard':
          if (data?.dashboard) {
            const newDashboard = createDashboard(
              data.dashboard.name, 
              data.dashboard.description
            );
            for (const widget of data.dashboard.widgets) {
              addWidget(newDashboard.id, widget);
            }
            toast.success(`Dashboard "${data.dashboard.name}" saved successfully!`);
            addAlert({
              title: 'Dashboard Saved',
              message: `${data.dashboard.name} has been created and saved`,
              type: 'success'
            });
            if (onDashboardAction) {
              onDashboardAction('edit', { ...newDashboard, widgets: data.dashboard.widgets });
            }
            toast.success(`Dashboard "${data.dashboard.name}" has been saved and opened in edit mode!`);
          }
          break;
        
        case 'open_editor':
          if (data?.dashboard) {
            if (onDashboardAction) {
              onDashboardAction('edit', data.dashboard);
            } else {
              setDashboardPreview(data.dashboard);
            }
            toast.success('Dashboard opened in edit mode');
          }
          break;
        
        case 'add_to_dashboard':
          if (data?.widget) {
            if (currentDashboard) {
              const position = findAvailablePosition(currentDashboard.widgets, data.widget);
              const widgetWithPosition = { ...data.widget, position };
              addWidget(currentDashboard.id, widgetWithPosition);
              toast.success(`Widget added to "${currentDashboard.name}"`);
              toast.success(`Widget "${data.widget.title}" added to "${currentDashboard.name}"`);
            } else {
              const newDashboard = createDashboard('New Dashboard', 'Created from AI chat');
              addWidget(newDashboard.id, data.widget);
              if (onDashboardAction) {
                onDashboardAction('edit', { ...newDashboard, widgets: [data.widget] });
              }
              toast.success('Widget added to new dashboard');
              toast.success(`Created new dashboard "${newDashboard.name}" with your widget and opened it in edit mode!`);
            }
          }
          break;
        
        case 'upload_csv':
          setUploadDialogOpen(true);
          break;
        
        case 'execute_query':
          if (data?.query) {
            try {
              const result = await executeQuery(data.query);
              toast.success(`Query executed successfully! Found ${result.length} rows.`);
              toast.success(`Query executed successfully! Found ${result.length} rows.`);
            } catch (error) {
              const errorMessage = error instanceof Error ? error.message : 'Query execution failed';
              setLastError(errorMessage);
              toast.error(`Query failed: ${errorMessage}`);
              toast.error(`Query failed: ${errorMessage}`);
            }
          }
          break;

        case 'export_csv':
          if (data?.result) {
            const csvContent = [
              Object.keys(data.result[0] || {}).join(','),
              ...data.result.map((row: any) =>
                Object.values(row).map(val =>
                  typeof val === 'string' && val.includes(',') ? `"${val}"` : val
                ).join(',')
              )
            ].join('\n');
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'query_results.csv';
            a.click();
            URL.revokeObjectURL(url);
            toast.success('Data exported to CSV');
          }
          break;

        case 'update_dashboard':
          if (data?.config && currentDashboard) {
            updateDashboard(currentDashboard.id, data.config);
            toast.success('Dashboard updated successfully');
            toast.success(`Dashboard "${currentDashboard.name}" updated successfully!`);
          } else if (data?.config && !currentDashboard) {
            toast.error('No dashboard is currently open. Please open a dashboard first to apply edits.');
          }
          break;
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Action failed';
      setLastError(errorMessage);
      toast.error(`Action failed: ${errorMessage}`);
      toast.error(`Action failed: ${errorMessage}`);
    }
  };

  const handleUploadSuccess = (tableName: string, rowCount: number) => {
    toast.success(`Successfully uploaded data to table "${tableName}" with ${rowCount} rows!`);
  };

  const renderAIComponent = (component: AIComponent) => {
    try {
      switch (component.type) {
        case 'widget':
          const widgetData = component.data as WidgetComponentData;
          return (
            <div className="border rounded-lg p-4 bg-gray-50 mt-3 w-full overflow-hidden">
              <div className="flex justify-between items-center mb-3 min-w-0">
                <div className="flex items-center gap-2 min-w-0 flex-1">
                  {widgetData.widget.type === 'chart' && <BarChart3 className="w-4 h-4 flex-shrink-0" />}
                  {widgetData.widget.type === 'metric' && <TrendingUp className="w-4 h-4 flex-shrink-0" />}
                  {widgetData.widget.type === 'table' && <TableIcon className="w-4 h-4 flex-shrink-0" />}
                  {widgetData.widget.type === 'text' && <FileText className="w-4 h-4 flex-shrink-0" />}
                  <h4 className="font-medium truncate">Widget Preview</h4>
                </div>
                <div className="flex gap-2 flex-shrink-0">
                  <Button 
                    size="sm" 
                    variant="outline"
                    onClick={() => handleComponentAction('add_to_dashboard', component.id, { widget: widgetData.widget })}
                    className="whitespace-nowrap"
                  >
                    <Plus className="w-4 h-4 mr-1" />
                    Add
                  </Button>
                </div>
              </div>
              <div className="bg-white rounded border overflow-auto" style={{ height: '280px', maxWidth: '100%' }}>
                <div style={{ minWidth: '300px', width: '100%', height: '100%' }}>
                  {widgetData.widget.type === 'chart' && <ChartWidget widget={widgetData.widget} />}
                  {widgetData.widget.type === 'metric' && <MetricWidget widget={widgetData.widget} />}
                  {widgetData.widget.type === 'table' && <TableWidget widget={widgetData.widget} />}
                  {widgetData.widget.type === 'text' && <TextWidget widget={widgetData.widget} />}
                </div>
              </div>
              {widgetData.showSQL && widgetData.widget.config.query && (
                <div className="mt-3 p-3 bg-gray-900 text-green-400 rounded text-sm font-mono overflow-auto">
                  <div className="flex items-center gap-2 mb-2">
                    <Code className="w-3 h-3 flex-shrink-0" />
                    <span className="text-xs font-sans">SQL Query</span>
                  </div>
                  <pre className="text-xs whitespace-pre-wrap break-all">
                    {widgetData.widget.config.query}
                  </pre>
                </div>
              )}
            </div>
          );

        case 'dashboard':
          const dashboardData = component.data as DashboardComponentData;
          return (
            <div className="border rounded-lg p-4 bg-gray-50 mt-3 w-full overflow-hidden">
              <div className="flex justify-between items-center mb-3 min-w-0">
                <div className="flex items-center gap-2 min-w-0 flex-1">
                  <Database className="w-4 h-4 flex-shrink-0" />
                  <h4 className="font-medium truncate">Dashboard Preview</h4>
                  <Badge variant="secondary" className="text-xs flex-shrink-0">
                    {dashboardData.dashboard.widgets.length} widgets
                  </Badge>
                </div>
                <div className="flex gap-2 flex-shrink-0">
                  <Button 
                    size="sm" 
                    variant="outline"
                    onClick={() => handleComponentAction('open_editor', component.id, dashboardData)}
                    className="whitespace-nowrap"
                  >
                    <Eye className="w-4 h-4 mr-1" />
                    Preview
                  </Button>
                  <Button 
                    size="sm"
                    onClick={() => handleComponentAction('save_dashboard', component.id, dashboardData)}
                    className="whitespace-nowrap"
                  >
                    <Save className="w-4 h-4 mr-1" />
                    Save
                  </Button>
                </div>
              </div>
              <div className="bg-white rounded border overflow-auto" style={{ height: '400px', maxWidth: '100%' }}>
                <div style={{ minWidth: '500px', width: '100%', height: '100%' }}>
                  <DashboardViewer dashboard={dashboardData.dashboard} embedded={true} />
                </div>
              </div>
              <div className="mt-3 text-sm text-gray-600 overflow-hidden">
                <p className="truncate"><strong>Name:</strong> {dashboardData.dashboard.name}</p>
                {dashboardData.dashboard.description && (
                  <p className="truncate"><strong>Description:</strong> {dashboardData.dashboard.description}</p>
                )}
              </div>
            </div>
          );

        case 'sql_result':
          const sqlData = component.data as SQLResultComponentData;
          return (
            <div className="border rounded-lg p-4 bg-gray-50 mt-3 w-full overflow-hidden">
              <div className="flex justify-between items-center mb-3 min-w-0">
                <div className="flex items-center gap-2 min-w-0 flex-1">
                  <Play className="w-4 h-4 flex-shrink-0" />
                  <h4 className="font-medium truncate">Query Results</h4>
                  <Badge variant="secondary" className="text-xs flex-shrink-0">
                    {sqlData.result.length} rows
                  </Badge>
                  {sqlData.executionTime && (
                    <Badge variant="outline" className="text-xs flex-shrink-0">
                      {Math.round(sqlData.executionTime)}ms
                    </Badge>
                  )}
                </div>
                <div className="flex gap-2 flex-shrink-0">
                  <Button 
                    size="sm" 
                    variant="outline"
                    onClick={() => {
                      const widget: Widget = {
                        id: `widget-${Date.now()}`,
                        type: 'table',
                        title: 'Query Results',
                        position: { x: 0, y: 0 },
                        size: { width: 600, height: 400 },
                        config: {
                          query: sqlData.query,
                          pageSize: 10
                        }
                      };
                      handleComponentAction('add_to_dashboard', component.id, { widget });
                    }}
                    className="whitespace-nowrap"
                  >
                    <BarChart3 className="w-4 h-4 mr-1" />
                    Widget
                  </Button>
                  <Button 
                    size="sm" 
                    variant="outline"
                    onClick={() => handleComponentAction('export_csv', component.id, sqlData)}
                    className="whitespace-nowrap"
                  >
                    <Download className="w-4 h-4 mr-1" />
                    Export
                  </Button>
                </div>
              </div>
              <div className="mb-3 p-3 bg-gray-900 text-green-400 rounded text-sm font-mono overflow-auto">
                <div className="flex items-center gap-2 mb-2">
                  <Code className="w-3 h-3 flex-shrink-0" />
                  <span className="text-xs font-sans">SQL Query</span>
                </div>
                <pre className="text-xs whitespace-pre-wrap break-all">
                  {sqlData.query}
                </pre>
              </div>
              <div className="bg-white rounded border overflow-auto" style={{ maxHeight: '300px', maxWidth: '100%' }}>
                {sqlData.result.length > 0 ? (
                  <table className="w-full text-sm min-w-full">
                    <thead className="bg-gray-100 sticky top-0">
                      <tr>
                        {Object.keys(sqlData.result[0]).map((key) => (
                          <th key={key} className="px-3 py-2 text-left font-medium border-b whitespace-nowrap">
                            {key}
                          </th>
                        ))}
                      </tr>
                    </thead>
                    <tbody>
                      {sqlData.result.map((row, index) => (
                        <tr key={index} className={index % 2 === 0 ? 'bg-white' : 'bg-gray-50'}>
                          {Object.values(row).map((value, valueIndex) => (
                            <td key={valueIndex} className="px-3 py-2 border-b whitespace-nowrap">
                              {typeof value === 'number' ? value.toLocaleString() : String(value)}
                            </td>
                          ))}
                        </tr>
                      ))}
                    </tbody>
                  </table>
                ) : (
                  <div className="p-4 text-center text-gray-500">
                    No results found
                  </div>
                )}
              </div>
            </div>
          );

        case 'upload_prompt':
          const uploadData = component.data as UploadPromptComponentData;
          return (
            <div className="border rounded-lg p-4 bg-gray-50 mt-3 w-full max-w-sm mx-auto overflow-hidden">
              <div className="text-center space-y-3">
                <Upload className="w-10 h-10 mx-auto text-gray-400" />
                <div>
                  <h4 className="font-medium mb-2 text-sm truncate">Upload CSV File</h4>
                  <p className="text-xs text-gray-600 break-words">{uploadData.message}</p>
                </div>
                <Button 
                  onClick={() => handleComponentAction('upload_csv', component.id)}
                  className="gap-2 text-xs h-8 px-3 w-full"
                  size="sm"
                >
                  <Upload className="w-3 h-3" />
                  Choose CSV File
                </Button>
                <p className="text-xs text-gray-500 break-words">
                  Accepted formats: {uploadData.acceptedTypes.join(', ')}
                </p>
              </div>
            </div>
          );

        case 'error':
          const errorData = component.data as ErrorComponentData;
          return (
            <div className="border rounded-lg p-4 bg-red-50 border-red-200 mt-3">
              <div className="flex items-start gap-3">
                <AlertCircle className="w-5 h-5 text-red-500 mt-0.5 flex-shrink-0" />
                <div className="flex-1">
                  <h4 className="font-medium text-red-800 mb-1">Error</h4>
                  <p className="text-sm text-red-700 mb-3">{errorData.error}</p>
                  {errorData.code && (
                    <Badge variant="destructive" className="text-xs mb-3">
                      {errorData.code}
                    </Badge>
                  )}
                  {errorData.suggestions && errorData.suggestions.length > 0 && (
                    <div className="space-y-1">
                      <p className="text-xs font-medium text-red-800">Suggestions:</p>
                      <ul className="text-xs text-red-700 space-y-1">
                        {errorData.suggestions.map((suggestion, index) => (
                          <li key={index} className="flex items-start gap-1">
                            <span className="text-red-400">•</span>
                            {suggestion}
                          </li>
                        ))}
                      </ul>
                    </div>
                  )}
                </div>
              </div>
            </div>
          );

        case 'tool_call':
          const toolCallData = component.data as { name: string; args: any };
          return (
            <div className="border rounded-lg p-4 bg-blue-50 border-blue-200 mt-3">
              <div className="flex items-center gap-2 mb-2">
                <Wrench className="w-4 h-4 text-blue-500" />
                <h4 className="font-medium text-blue-800">Tool Call: {toolCallData.name}</h4>
              </div>
              <div className="bg-gray-900 text-blue-200 rounded p-3 text-sm font-mono">
                <pre className="text-xs whitespace-pre-wrap break-all">
                  {JSON.stringify(toolCallData.args, null, 2)}
                </pre>
              </div>
            </div>
          );

          case 'tool_result':
            const toolResultData = component.data as { name: string; result: any };
            return (
              <div className="border rounded-lg p-4 bg-gray-50 mt-3">
                <div 
                  className="flex items-center gap-2 mb-2 cursor-pointer"
                  onClick={() => setCollapsedToolResults(prev => ({
                    ...prev,
                    [component.id]: !prev[component.id] || false
                  }))}
                >
                  <CheckCircle className="w-4 h-4 text-green-500" />
                  <h4 className="font-medium">Tool Result: {toolResultData.name}</h4>
                  <span className="ml-auto text-sm text-gray-500">
                    {collapsedToolResults[component.id] ?? true ? 'Show' : 'Hide'}
                  </span>
                </div>
                {!(collapsedToolResults[component.id] ?? true) && (
                  <div className="bg-white rounded border p-3 text-sm">
                    <ReactMarkdown
                      remarkPlugins={[remarkGfm]}
                      components={{
                        h1: ({node, ...props}) => <h1 className="text-xl font-bold my-2" {...props} />,
                        h2: ({node, ...props}) => <h2 className="text-lg font-semibold my-2" {...props} />,
                        p: ({node, ...props}) => <p className="mb-2" {...props} />,
                        ul: ({node, ...props}) => <ul className="list-disc list-inside mb-2" {...props} />,
                        ol: ({node, ...props}) => <ol className="list-decimal list-inside mb-2" {...props} />,
                        code: ({node, ...props}) => <code className="bg-gray-800 text-white px-1 rounded" {...props} />,
                        strong: ({node, ...props}) => <strong className="font-semibold" {...props} />,
                        em: ({node, ...props}) => <em className="italic" {...props} />,
                      }}
                    >
                      {typeof toolResultData.result === 'string' ? toolResultData.result : JSON.stringify(toolResultData.result, null, 2)}
                    </ReactMarkdown>
                  </div>
                )}
              </div>
            );
        default:
          return null;
      }
    } catch (error) {
      console.error('Error rendering component:', error);
      return (
        <div className="border rounded-lg p-4 bg-red-50 border-red-200 mt-3">
          <div className="flex items-center gap-2 text-red-600">
            <AlertCircle className="w-4 h-4" />
            <span className="text-sm">Error rendering component</span>
          </div>
        </div>
      );
    }
  };

  const handleSuggestionClick = (suggestion: string) => {
    setInput(suggestion);
  };

  const suggestedPrompts = [
    "Analyze the uploaded CSV file and provide insights",
    "Generate a comprehensive report with recommendations",
    "Perform sentiment analysis on text columns",
    "Show statistical summary of numerical data",
    "Compare different departments or categories"
  ];

  return (
    <div className="flex h-full">
      <div className="flex-1 flex flex-col">
      <ScrollArea className="flex-1 p-4">
  <div className="space-y-4 max-w-4xl mx-auto">
    {displayMessages.length === 0 && !isTyping ? (
      <div className="flex flex-col items-center justify-center h-full text-center">
        <Brain className="w-16 h-16 text-gray-400 mb-4" />
        <h2 className="text-xl font-semibold mb-2">
          Welcome to Dashboard Analysis Agent
        </h2>
        <p className="text-gray-600 mb-6 max-w-md">
          I can autonomously analyze your CSV files, perform statistical analysis, sentiment analysis, and generate comprehensive reports.
        </p>
        <div className="mb-6 p-4 bg-blue-50 rounded-lg">
          <div className="flex items-center space-x-2 text-blue-800">
            <Upload className="w-4 h-4" />
            <span className="text-sm font-medium">Upload a CSV file to get started</span>
          </div>
          <Button 
            onClick={() => setUploadDialogOpen(true)}
            className="gap-2 text-xs h-8 px-3 w-full mt-3"
            size="sm"
          >
            <Upload className="w-3 h-3" />
            Choose CSV File
          </Button>
          <p className="text-xs text-gray-500 break-words mt-2">
            Accepted formats: .csv
          </p>
        </div>
        <div className="space-y-2 max-w-md w-full">
          <p className="text-sm text-gray-600 mb-3">Try these prompts:</p>
          {suggestedPrompts.map((prompt, index) => (
            <Button
              key={index}
              variant="outline"
              onClick={() => setInput(prompt)}
            >
              <Sparkles className="w-3 h-3 mr-1" />
              {prompt}
            </Button>
          ))}
        </div>
      </div>
    ) : (
      <>
        {[...displayMessages, ...(isTyping && lastUserInput && displayMessages[displayMessages.length - 1]?.role !== 'user' && !displayMessages.some(msg => msg.role === 'assistant' && msg.timestamp > new Date(Date.now() - 1000)) ? [{
          id: Date.now().toString(),
          content: lastUserInput,
          role: 'user',
          timestamp: new Date(),
        } as EnhancedChatMessage] : [])].map((message) => (
          <div key={message.id} className="space-y-2">
            <div className={`flex items-start space-x-3 ${message.role === 'user' ? 'justify-end' : ''}`}>
            {message.role === 'assistant' && (
              <Avatar className="w-8 h-8 bg-gradient-to-br from-emerald-400 via-blue-500 to-purple-600 flex-shrink-0 shadow-sm">
                <AvatarFallback className="bg-transparent">
                  {message.aiResponse?.components?.some(comp => comp.type === 'tool_call') ? (
                    <Wrench className="w-4 h-4 text-white drop-shadow-sm" />
                  ) : message.aiResponse?.components?.some(comp => comp.type === 'tool_result') ? (
                    <CheckCircle className="w-4 h-4 text-white drop-shadow-sm" />
                  ) : (
                    <Brain className="w-4 h-4 text-white drop-shadow-sm" />
                  )}
                </AvatarFallback>
              </Avatar>
            )}
              <div className={`max-w-[80%] min-w-0 ${message.role === 'user' ? 'order-first' : ''}`}>
                <Card className={`p-3 ${message.role === 'user' ? 'bg-blue-600 text-white border-blue-600' : 'bg-white border-gray-200'}`}>
                  <ReactMarkdown
                    remarkPlugins={[remarkGfm]}
                    components={{
                      table: ({ node, ...props }) => (
                        <div className="my-4">
                          <ScrollArea className="w-full custom-scrollbar">
                            <div className="min-w-[200px]">
                              <Table {...props} />
                            </div>
                            <ScrollBar orientation="horizontal" />
                          </ScrollArea>
                        </div>
                      ),
                      thead: ({ node, ...props }) => <TableHeader {...props} />,
                      tbody: ({ node, ...props }) => <TableBody {...props} />,
                      tr: ({ node, ...props }) => <TableRow {...props} />,
                      th: ({ node, ...props }) => (
                        <TableHead className="min-w-[50px] max-w-[300px] break-words font-semibold text-gray-900 p-4" {...props} />
                      ),
                      td: ({ node, ...props }) => (
                        <TableCell className="min-w-[50px] max-w-[300px] break-words font-mono text-xs text-gray-700 p-4" {...props} />
                      ),
                      h1: ({ node, ...props }) => <h1 className="text-2xl font-bold mb-4" {...props} />,
                      h2: ({ node, ...props }) => <h2 className="text-xl font-semibold mb-3" {...props} />,
                      h3: ({ node, ...props }) => <h3 className="text-lg font-semibold mb-2" {...props} />,
                      h4: ({ node, ...props }) => <h4 className="text-base font-semibold mb-2" {...props} />,
                      h5: ({ node, ...props }) => <h5 className="text-sm font-semibold mb-1" {...props} />,
                      h6: ({ node, ...props }) => <h6 className="text-sm font-medium mb-1" {...props} />,
                      p: ({ node, ...props }) => <p className="text-sm leading-relaxed break-words mb-2" {...props} />,
                      ul: ({ node, ...props }) => <ul className="list-disc pl-6 text-sm leading-relaxed mb-2" {...props} />,
                      ol: ({ node, ...props }) => <ol className="list-decimal pl-6 text-sm leading-relaxed mb-2" {...props} />,
                      li: ({ node, ...props }) => <li className="ml-4 text-sm leading-relaxed mb-1">{props.children}</li>,
                      code: ({ node, ...props }) => <code className="bg-gray-600 text-white px-2 py-1 rounded text-xs" {...props} />,
                      strong: ({ node, ...props }) => <strong className="font-semibold text-sm" {...props} />,
                      em: ({ node, ...props }) => <em className="italic text-sm" {...props} />,
                    }}
                  >
                    {message.content}
                  </ReactMarkdown>
                  <div className="text-xs opacity-70 mt-2">
                    {format(message.timestamp, 'HH:mm')}
                  </div>
                </Card>
                {message.aiResponse?.components?.map((component) => (
                  <div key={component.id}>
                    {renderAIComponent(component)}
                  </div>
                ))}
                {message.suggestions && (
                  <div className="flex flex-wrap gap-2 mt-3">
                    {message.suggestions.map((suggestion, index) => (
                      <Button
                        key={index}
                        variant="outline"
                        size="sm"
                        onClick={() => handleSuggestionClick(suggestion)}
                        className="text-xs h-7 px-3 bg-gray-50 hover:bg-gray-100 border-gray-200"
                      >
                        <Sparkles className="w-3 h-3 mr-1" />
                        {suggestion}
                      </Button>
                    ))}
                  </div>
                )}
              </div>
              {message.role === 'user' && (
                <Avatar className="w-8 h-8 bg-gray-100 flex-shrink-0">
                  <AvatarFallback>
                    <User className="w-4 h-4 text-gray-600" />
                  </AvatarFallback>
                </Avatar>
              )}
            </div>
          </div>
        ))}
{isTyping && lastUserInput && !displayMessages.some((msg, index) => msg.role === 'assistant' && index > displayMessages.findIndex(m => m.id === lastUserMessageId)) && (
  <div className="flex items-start space-x-3">
    <Avatar className="w-8 h-8 bg-gradient-to-br from-emerald-400 via-blue-500 to-purple-600 shadow-sm">
      <AvatarFallback className="bg-transparent">
        <Brain className="w-4 h-4 text-white drop-shadow-sm" />
      </AvatarFallback>
    </Avatar>
    <Card className="p-3 bg-white border-gray-200">
      <div className="flex space-x-1">
        <div className="w-2 h-2 bg-gray-400 rounded-full animate-bounce"></div>
        <div className="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style={{ animationDelay: '0.1s' }}></div>
        <div className="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style={{ animationDelay: '0.2s' }}></div>
      </div>
    </Card>
  </div>
)}
        <div ref={scrollRef} />
      </>
    )}
  </div>
</ScrollArea>
        <div className="border-t border-gray-200 p-4">
          <div className="max-w-4xl mx-auto space-y-4">
            <div className="flex space-x-2 items-end">
              <div className="flex-1 relative">
                <Textarea
                  value={input}
                  onChange={(e) => setInput(e.target.value)}
                  onKeyDown={(e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                      e.preventDefault();
                      handleSend();
                    }
                  }}
                  placeholder="Ask me to create dashboards, analyze data, or upload CSV files... (Shift+Enter for new line)"
                  className="min-h-[40px] max-h-32 text-sm resize-none border-gray-300 focus:border-blue-500 focus:ring-blue-500 w-full custom-scrollbar"
                  disabled={isLoading}
                  rows={1}
                  style={{
                    height: 'auto',
                    minHeight: '40px',
                    maxHeight: '128px'
                  }}
                  onInput={(e) => {
                    const target = e.target as HTMLTextAreaElement;
                    target.style.height = 'auto';
                    target.style.height = Math.min(target.scrollHeight, 128) + 'px';
                  }}
                />
              </div>
              <Button
                onClick={handleSend}
                disabled={isLoading || !input.trim()}
                size="sm"
                className="px-4 h-10 flex-shrink-0"
              >
                <Send className="w-4 h-4" />
              </Button>
            </div>
            {error && (
              <div className="text-sm text-red-600">
                {error.message}
              </div>
            )}
          </div>
        </div>
      </div>
      {dashboardPreview && (
        <div className="w-96 border-l border-gray-200 bg-gray-50">
          <div className="p-4 border-b border-gray-200">
            <div className="flex items-center justify-between">
              <h3 className="font-medium">Dashboard Preview</h3>
              <Button
                size="sm"
                variant="outline"
                onClick={() => setDashboardPreview(null)}
              >
                ✕
              </Button>
            </div>
          </div>
          <div className="h-full overflow-auto p-4">
            <DashboardViewer dashboard={dashboardPreview} embedded={true} />
          </div>
        </div>
      )}
      <CSVUploadDialog 
        open={uploadDialogOpen} 
        onOpenChange={setUploadDialogOpen}
        onSuccess={handleUploadSuccess}
      />
    </div>
  );
}